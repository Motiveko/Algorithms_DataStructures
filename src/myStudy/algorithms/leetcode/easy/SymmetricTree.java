package myStudy.algorithms.leetcode.easy;

import java.util.*;
/*
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3
Note:

Bonus points if you could solve it both recursively and iteratively.

Tags: Tree, Depth-first Search, Breadth-first Search
*/

public class SymmetricTree {

	
	public static boolean isSymmetric(Integer[] ar) {
	
		Stack<Integer> stack = new Stack<>();
		Deque<Integer> queue = new ArrayDeque<>();
		
		final int LEVEL_TOKEN = -1;
		int i=1;
		while( i<=length) {
			//2의 지수승일 때 토큰넣기 , 좌큐 우스택으로 비교
			if(i == )
			
		}
	}
	
	
	
}
